\chapter{Interval}


\section{Introduction}
\rih{Two-way range.} The current scanning node as the pivot, need to scan its left neighbors and right neighbors. 
$$
|\leftarrow p \rightarrow |
$$

If the relationship between the pivot and its neighbors is symmetric, since scanning range is $[i-k, i+k]$ and iterating from left to right, only consider $[i-k, i]$ to avoid duplication.
$$
|\leftarrow p
$$

\section{Operations}
\runinhead{Merge intervals.} Given a collection of intervals, merge all overlapping intervals.

\textbf{Core clues}:
\begin{enumerate}
\item Sort the intervals
\item When does the overlapping happens?
[0, 5) vs. [2, 6); [0, 5) vs. [2, 4)
\end{enumerate}
\begin{python}
def merge(self, itvls):
    itvls.sort(key=lambda x: x.start)
    ret = [itvls[0]]
    for cur in itvls[1:]:
        pre = ret[-1]
        if cur.start <= pre.end:  # overlap
            pre.end = max(pre.end, cur.end)
        else:
            ret.append(cur)

    return ret
\end{python}

\runinhead{Insert intervals.} Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). Assume that the intervals were initially sorted according to their start times.

\textbf{Core clues}
\begin{enumerate}
\item Partition the original list of intervals to left-side intervals and right-side intervals according to the new interval. 
\item Merge the intermediate intervals with the new interval. Need to mathematically prove it works as expected.
\end{enumerate}

\begin{python}
def insert(self, itvls, newItvl):
    s, e = newItvl.start, newItvl.end
    left = filter(lambda x: x.end < s, itvls)
    right = filter(lambda x: x.start > e, itvls)
    if len(left) + len(right) != len(itvls):
        s = min(s, itvls[len(left)].start)
        e = max(e, itvls[~len(right)].end)
        # itvls[-len(right)-1]

    return left + [Interval(s, e)] + right
\end{python}

\section{Event-driven algorithms}
\subsection{Introduction}
The core philosophy of event-driven algorithm:
\begin{enumerate}
\item \textbf{Events}: define \textit{events}; the events are sorted by time of appearance.
\item \textbf{Accumulator}: define \textit{accumulator} as the accumulated impacts of the event.
\item \textbf{Transition}: define \textit{transition functions} among events impacting the accumulator.
\end{enumerate} 

\subsection{Line Sweeping}
\runinhead{Maximal Overlaps}. Given a list of number intervals, find max number of overlapping
intervals.

\rih{Core clues:}
\begin{enumerate}
\item \textbf{Events}: Every new start of an interval is an event. Scan the sorted intervals (sort the interval by \textit{start}).
\item \textbf{Accumulator}: the maximum number of overlap. As approximate by a heap, which stores the \textit{end} of the interval. 
\item \textbf{Transition}: Put the ending time into heap, and pop the ending time earlier than the new start time from heap. And we need min-heap to pop the early ones.
\end{enumerate}

\begin{python}
def max_overlapping(intervals):
    maxa = 0
    intervals.sort(key=lambda x: x.start)
    h_end = []
    for itvl in intervals:
        heapq.heappush(h_end, itvl.end)
        
        while h_end and h_end[0] <= itvl.start:
            heapq.heappop(h_end)

        maxa = max(maxa, len(h_end))

    return maxa
\end{python}

\runinhead{The horizontal line balancing above and below.} Given a 2D integer array $squares$. Each $squares_i = [x_i, y_i, l_i]$, representing the coordinates of the bottom-left point and the side length of a square parallel to the x-axis.

Find the minimum y-coordinate value of a horizontal line such that the total area of the squares above the line equals to that below the line. Note: Squares may overlap. Overlapping areas should be counted multiple times.

\rih{Core clues:}
\begin{enumerate}
\item \textbf{Events}: Every $y_i$ repreents a new square, with a begining and an end. 
\item \textbf{Accumulator}: $F(y) = AreaBelow(y)$, by the horizontal line $y$. 
\item \textbf{Transition}: The rate of change of $F(y)$ is $slope$. The $slope$ is the accumulated width at $y$, of all the squares under $y$. Each event contains a $\Delta slope$ that impacts the accumulated slope. More formally,
\begin{align*}
  \frac{\dd}{\dd y}F(y) &= slope(y) \\
  slope(y) &= \sum_{\substack{\text{all squares }i \\ y_i \le y < y_i + l_i}} l_i \\ 
  \frac{\dd}{\dd y}slope(y) &= \Delta slope_y \text{ from } events
\end{align*}
\end{enumerate}
\begin{python}
def separateSquares(self, squares):
    """
    Event driven. Line Sweep.
    F(y) = AreaBelow(y)
    dF/dy = slope, the rate of change of F(y)
    F(y) is monotonically increasing 
    """
    events = []
    total_area = 0
    for x, y, l in squares:
        # (y-coordiate, delta_slope)
        events.append((y, l))
        events.append((y+l, -l))
        total_area += l*l
    
    events.sort()
    target = total_area / 2

    F = 0 
    slope = 0
    prev_y = events[0][0]
    for y, d_slope in events:
        F += (y - prev_y) * slope
        if F >= target:
            return y - (F - target) / slope

        slope += d_slope
        prev_y = y
    
    return prev_y
\end{python}
