% !TEX root = algo-quicksheet.tex
\chapter{Arithmetic}


\section{Big Number}
\rih{Plus One.} Given a non-negative number represented as an array of digits, plus one to the number.
\begin{python}
def plusOne(self, digits):
    for i in range(len(digits)-1, -1, -1):
        digits[i] += 1
        if digits[i] < 10:
            return digits
        else:
            digits[i] -= 10

    # if not return within the loop 
    digits.insert(0, 1)
    return digits
\end{python}

\runinhead{Multiplication.} The key to big number multiplication is to break down the problem:
\begin{enumerate}
\item Multiply one digit by one.
\item Add one big number by one.
\item Add a list of big number with increasing significance
\end{enumerate}
Details see \href{https://github.com/algorhythms/LeetCode/blob/master/042%20Multiply%20Strings.py}{code}.
\section{Calculator}
\subsection{Parsing}
\runinhead{Basic calculator.} Given a string s which represents an expression, evaluate this expression and return its value. 
\begin{python}
s = "3+2*2"
s = " 3/2 "
s = " 23+5 / 2 "
\end{python}
\runinhead{Core Clues:}
\begin{enumerate}
\item Parse the string char by char
\item \hl{Lookback} number and lookback operator
\item Sentiels: \pyinline{None}.
\item Append \pyinline{"\0"} to flush
\end{enumerate}
\begin{python}
def calculate(self, s: str) -> int:
    stk = []
    num = None
    op = None

    for c in s + '\0': # sentinel to flush the last number
        if c == ' ':
            continue

        if c.isdigit():
            num = (num if num else 0) * 10 + int(c)
            continue
            
        # c is operator, assign c to op, process op first
        if op == '+' or op is None:
            stk.append(num)
        elif op == '-':
            stk.append(-num)
        elif op == '*':
            stk[-1] = stk[-1] * num
        elif op == '/':
            # truncate toward zero (not use // for negatives)
            stk[-1] = int(stk[-1] / num)
        else:
            raise

        num = None        
        op = c

    return sum(stk)
\end{python}

\runinhead{Add brackets ().}
\begin{enumerate}
\item Use the original function as a recursive function
\item A \pyinline{"("} is a recurisve call stack, and A \pyinline{")"} is a return the current recurisve call. 
\end{enumerate}
\begin{python}
def calculate(self, s: str) -> int:
    s += '\0'
    val, _ = self.parse(s, 0)
    return val

def parse(self, s, i: int) -> tuple[int, int]:
    stk = []
    num = None
    op = None

    while i < len(s):
        c = s[i]
        if c == ' ':
            i += 1
            continue

        if c.isdigit():
            num = (num if num else 0) * 10 + int(c)
            i += 1
            continue

        if c == '(':
            # Evaluate bracketed expression
            subtotal, j = self.parse(s, i + 1)
            num = subtotal
            i = j
            continue

        # at this point c is an operator or ')'
        # assign c to op
        num = num if num else 0
        if op == '+' or op is None:
            stk.append(num)
        elif op == '-':
            stk.append(-num)
        elif op == '*':
            stk[-1] = stk[-1] * num
        elif op == '/':
            # Truncate toward zero
            stk[-1] = int(stk[-1] / num)
        else:
            raise
        num = None
            
        if c == ')':
            # finish this level, skipping ')'
            return sum(stk), i + 1
        else:
            op = c  # include '\0'
            i += 1

    return sum(stk), i
\end{python}

Alternatively, iterative Approach: note that the order inside the for-loop cannot change
\begin{python}
def calculate(self, s: str) -> int:
    stk = []  # holds signed ints, plus (, the op just before (
    num = None
    op = None

    for c in s + '\0':
        if c == ' ':
            continue

        if c.isdigit():
            num = (num if num else 0) * 10 + int(c)
            continue

        if c == '(':
            # Save the operator before ( 
            stk.append(op)  # +/-
            stk.append('(')
            op = None # reset 
            continue
		
        # c is +/-/): flush
        if num != None:
            if op == '+' or op is None:
                stk.append(num)
            else:  # '-'
                stk.append(-num)
            num = None

        if c == ')':
            subtotal = 0
            while stk and stk[-1] != '(':
                subtotal += stk.pop()
            stk.pop()  # remove (
            
            prev_op = stk.pop()  # op before (
            if prev_op == '+' or prev_op is None:
                stk.append(subtotal)
            else:  # '-'
                stk.append(-subtotal)
            # op remains unchanged
        else:  # only for +/-            
            op = c

    return sum(stk)
\end{python}
Adding \pyinline{"*/"}
\begin{python}
def calculate(self, s: str) -> int:
    stk = []
    num = None
    op = None

    for c in s + '\0':
        if c == ' ':
            continue

        if c.isdigit():
            num = (num if num else 0) * 10 + int(c)
            continue

        if c == '(':
            stk.append(op)
            stk.append('(')
            op = None  # reset
            continue

        if num != None:
            if op == '+' or op is None:
                stk.append(num)
            elif op == '-':
                stk.append(-num)
            elif op == '*':
                stk[-1] = stk[-1] * num
            else:  # '/'
                stk[-1] = int(stk[-1] / num)
            num = None

        if c == ')':
            subtotal = 0
            while stk and stk[-1] != '(':
                subtotal += stk.pop()
            stk.pop()  # remove (
            
            prev_op = stk.pop()
            if prev_op == '+' or prev_op is None:
                stk.append(subtotal)
            elif prev_op == '-':
                stk.append(-subtotal)
            elif prev_op == '*':
                stk[-1] = stk[-1] * subtotal
            else:  # '/'
                stk[-1] = int(stk[-1] / subtotal)
        else:
            op = c

    return sum(stk)
\end{python}
\section{Appendix - Polish Notations}
Polish Notation is in-fix while Reverse Polish Notation is post-fix. 

Reverse Polish notation (RPN) is a mathematical notation in which every operator follows all of its operands (i.e. operands are followed by operators). RPN should be treated as the orthogonal expression.  

Polish notation (PN) is a mathematical notation in which every operator is followed by its operands. 
\subsection{Evaluate post-fix expressions}\label{section:evaluationPostFix}
Consider: 

In-fix
\begin{python}
5 + ((1 + 2) * 4) - 3
\end{python}

Post-fix
\begin{python}
5 1 2 + 4 * + 3 - 
\end{python}
Straightforward: use a \textit{stack} to store the number. Iterate the input, push
stack when hit numbers, pop stack when hit operators.
\subsection{Convert in-fix to post-fix (RPN)}
\pyinline{ret} stores the final result of reverse polish notation. \pyinline{stk} stores
the temporary result in strictly increasing order. 

In-fix
\begin{python}
5 + ((1 + 2) * 4) - 3
\end{python}

can be written as
\begin{python}
5 1 2 + 4 * + 3 - 
\end{python}
Core clues:
\begin{enumerate}
\item \rih{Stack}. The stack temporarily stores the operators of \textit{strictly increasing precedence order}, except for brackets, which are put onto stack directly.
\item \rih{Precedence}. Digits have the highest precedence, followed by \pyinline{*, /, +, (}. Notice that \pyinline{(} operator itself has the \textit{lowest} precedence.
\item \rih{Bracket}. \textit{Match} the brackets. 
\end{enumerate}
Code:
\begin{python}
def infix2postfix(self, lst):
  stk = []
  ret = []  # post fix result
  for elt in lst:
    if elt.isdigit():
      ret.append(elt)
    elif elt == "(":
      stk.append(elt)
    elif elt == ")":
      while stk and stk[-1] != "(":
        ret.append(stk.pop())
      stk.pop()  # pop "("
    else:
      # maintain invariant
      while stk and not precdn(stk[-1]) < precdn(elt):
        ret.append(stk.pop())
      stk.append(elt)

  while stk:  # clean up 
    ret.append(stk.pop())

  return ret
\end{python}

\subsection{Convert in-fix to pre-fix (PN)}
PN is the \textit{reverse} of RPN, thus, scan the expression from right to left; and \pyinline{stk} stores the temporary result in \textit{non-decreasing} order, except for brackets.


In-fix
\begin{python}
5 + ((1 + 2) * 4) - 3
\end{python}

can be written as the intermediate representation (IR)
\begin{python}
3 4 2 1 + * 5 + -
\end{python}

reverse as the pre-fix
\begin{python}
- + 5 * + 1 2 4 3
\end{python}

\begin{python}
  def infix2prefix(self, lst):
    """starting from right the left"""
    stk = []
    pre = []
    for elt in reversed(lst):
      if elt.isdigit():
        pre.append(elt)
      elif elt == ")":
        stk.append(elt)
      elif elt == "(":
        while stk and stk[-1] != ")":
          pre.append(stk.pop())
        stk.pop()
      else:
        # maintain invariant
        while stk and not precdn(stk[-1]) <= precdn(elt):  
          pre.append(stk.pop())
        stk.append(elt)

    while stk:
      pre.append(stk.pop())

    pre.reverse()
    return pre
\end{python}


\subsection{Evaluate pre-fix (PN) expressions}
Consider: 

In-fix
\begin{python}
5 + ((1 + 2) * 4) - 3
\end{python}

Pre-fix
\begin{python}
- + 5 * + 1 2 4 3
\end{python}

reverse as the intermediate representation (IR)
\begin{python}
3 4 2 1 + * 5 + -
\end{python}
Put into \textit{stack}, similar to evaluating post-fix \ref{section:evaluationPostFix}, but pay attention to operands order, which should be reversed when hitting a operator. 
